*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*
> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files. Index metadata is provided via the HTML comment markers in this section.

# Index
<!-- PRODEX_INDEX_RANGE: L8-L23 -->
<!-- PRODEX_FILE_COUNT: 16 -->
<!-- PRODEX_INDEX_LIST_START -->
- [src/Support/DgpError.php](#1)  L27-L102
- [src/Support/DgpErrorCode.php](#2)  L103-L138
- [src/Support/Exceptions/AuthException.php](#3)  L139-L153
- [src/Support/Exceptions/DgpException.php](#4)  L154-L170
- [src/Support/Exceptions/ProviderException.php](#5)  L171-L185
- [src/Support/Exceptions/RateLimitedException.php](#6)  L186-L210
- [src/Support/Exceptions/TransportException.php](#7)  L211-L225
- [src/Support/Exceptions/ValidationException.php](#8)  L226-L242
- [src/Support/Hydration/DtoHydrator.php](#9)  L243-L451
- [src/Support/Hydration/HydratesFromArray.php](#10)  L452-L485
- [src/Support/Result.php](#11)  L486-L616
- [src/Support/Serialization/Arrayable.php](#12)  L617-L635
- [src/Support/Serialization/Normalizes.php](#13)  L636-L771
- [src/Support/Testing/FakeClock.php](#14)  L772-L822
- [src/Support/Testing/FakeTransport.php](#15)  L823-L921
- [src/Support/Validation/PayloadValidator.php](#16)  L922-L955
<!-- PRODEX_INDEX_LIST_END -->

---
---
#### 1


` File: src/Support/DgpError.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support;

use JsonSerializable;
use Throwable;
use Dgp\Sdk\Support\Serialization\Arrayable;

final readonly class DgpError implements Arrayable, JsonSerializable
{
    public function __construct(
        public DgpErrorCode $code,
        public string       $message,
        /** @var array<string, mixed>|null */
        public ?array       $details = null,
        public ?string      $providerCode = null,
        public ?int         $httpStatus = null,
        public ?int         $retryAfterSeconds = null,
        /** @var array<string, mixed>|null */
        public ?array       $meta = null,
    ) {}

    public static function unknown(string $message = 'Unknown error', ?Throwable $e = null): self
    {
        return new self(
            DgpErrorCode::UNKNOWN,
            $message,
            $e ? ['exception' => $e::class, 'exception_message' => $e->getMessage()] : null
        );
    }

    public static function fromThrowable(Throwable $e, ?DgpErrorCode $fallback = null): self
    {
        $code = $fallback ?? DgpErrorCode::UNKNOWN;

        return new self(
            $code,
            $e->getMessage() ?: $code->value,
            [
                'exception' => $e::class,
                'file' => $e->getFile(),
                'line' => $e->getLine(),
            ],
        );
    }

    /** @return array<string, mixed> */
    public function toArray(): array
    {
        return array_filter([
            'code' => $this->code->value,
            'message' => $this->message,
            'details' => $this->details,
            'provider_code' => $this->providerCode,
            'http_status' => $this->httpStatus,
            'retry_after_seconds' => $this->retryAfterSeconds,
            'meta' => $this->meta,
        ], static fn ($v) => $v !== null);
    }

    /** @return array<string, mixed> */
    public function jsonSerialize(): array
    {
        return $this->toArray();
    }
}
```

---
#### 2


` File: src/Support/DgpErrorCode.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support;

enum DgpErrorCode: string
{
    case UNKNOWN            = 'unknown';

    // request/validation
    case INVALID_PARAMS     = 'invalid_params';
    case VALIDATION_FAILED  = 'validation_failed';
    case UNSUPPORTED        = 'unsupported';

    // auth / config
    case AUTH_FAILED        = 'auth_failed';
    case MISCONFIGURED      = 'misconfigured';

    // provider/business
    case INSUFFICIENT_FUNDS = 'insufficient_funds';
    case PROVIDER_ERROR     = 'provider_error';

    // infra/flow control
    case RATE_LIMITED       = 'rate_limited';
    case TEMPORARY_FAILURE  = 'temporary_failure';
    case TRANSPORT_ERROR    = 'transport_error';
}
```

---
#### 3


` File: src/Support/Exceptions/AuthException.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support\Exceptions;

final class AuthException extends DgpException {}
```

---
#### 4


` File: src/Support/Exceptions/DgpException.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support\Exceptions;

use RuntimeException;

class DgpException extends RuntimeException {}
```

---
#### 5


` File: src/Support/Exceptions/ProviderException.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support\Exceptions;

final class ProviderException extends DgpException {}
```

---
#### 6


` File: src/Support/Exceptions/RateLimitedException.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support\Exceptions;

final class RateLimitedException extends DgpException
{
    public function __construct(
        public readonly ?int $retryAfterSeconds = null,
        string $message = 'Rate limited',
        int $code = 0,
        ?\Throwable $previous = null
    ) {
        parent::__construct($message, $code, $previous);
    }
}
```

---
#### 7


` File: src/Support/Exceptions/TransportException.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support\Exceptions;

final class TransportException extends DgpException {}
```

---
#### 8


` File: src/Support/Exceptions/ValidationException.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support\Exceptions;

final class ValidationException extends DgpException
{
}
```

---
#### 9


` File: src/Support/Hydration/DtoHydrator.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support\Hydration;

use BackedEnum;
use DateTimeImmutable;
use DateTimeInterface;
use ReflectionClass;
use ReflectionNamedType;
use ReflectionParameter;
use ReflectionType;
use ReflectionUnionType;
use RuntimeException;

final class DtoHydrator
{
    /**
     * Hydrate a DTO by mapping $data keys to the target class constructor parameters.
     *
     * - looks up keys by: exact, snake_case, camelCase
     * - hydrates nested objects if the target type has a static fromArray(array): self
     *
     * @param class-string $class
     * @param array<string,mixed> $data
     */
    public static function hydrate(string $class, array $data): object
    {
        $rc = new ReflectionClass($class);
        $ctor = $rc->getConstructor();

        if (!$ctor) {
            return $rc->newInstance();
        }

        $args = [];
        foreach ($ctor->getParameters() as $p) {
            $args[] = self::resolveParam($p, $data, $class);
        }

        return $rc->newInstanceArgs($args);
    }

    /**
     * @param class-string $class
     * @param array<int, array<string,mixed>> $items
     * @return array<int, object>
     */
    public static function hydrateList(string $class, array $items): array
    {
        $out = [];
        foreach ($items as $row) {
            $out[] = self::hydrate($class, $row);
        }
        return $out;
    }

    /**
     * @param array<string,mixed> $data
     */
    private static function resolveParam(ReflectionParameter $p, array $data, string $class): mixed
    {
        $name = $p->getName();
        $key = self::findKey($data, $name);

        if ($key === null) {
            if ($p->isDefaultValueAvailable()) {
                return $p->getDefaultValue();
            }

            if ($p->allowsNull()) {
                return null;
            }

            throw new RuntimeException("DtoHydrator: missing required key '{$name}' for {$class}.");
        }

        $value = $data[$key];
        return self::castToParamType($p->getType(), $value);
    }

    /**
     * Find the best key in $data matching the param name.
     *
     * @param array<string,mixed> $data
     */
    private static function findKey(array $data, string $paramName): ?string
    {
        $candidates = [
            $paramName,
            self::toSnake($paramName),
            self::toCamel($paramName),
        ];

        foreach ($candidates as $k) {
            if (array_key_exists($k, $data)) {
                return $k;
            }
        }

        return null;
    }

    private static function castToParamType(?ReflectionType $type, mixed $value): mixed
    {
        if ($type === null) {
            return $value;
        }

        // Union type: try each option until one fits/hydrates
        if ($type instanceof ReflectionUnionType) {
            foreach ($type->getTypes() as $t) {
                try {
                    return self::castToParamType($t, $value);
                } catch (\Throwable) {
                    // try next union member
                }
            }

            // If none match, just return raw
            return $value;
        }

        if (!($type instanceof ReflectionNamedType)) {
            return $value;
        }

        if ($value === null) {
            return null;
        }

        $typeName = $type->getName();

        // Built-ins
        if ($type->isBuiltin()) {
            return match ($typeName) {
                'int' => (int)$value,
                'float' => (float)$value,
                'string' => (string)$value,
                'bool' => (bool)$value,
                'array' => (array)$value,
                default => $value,
            };
        }

        // DateTimeInterface
        if (is_a($typeName, DateTimeInterface::class, true)) {
            if ($value instanceof DateTimeInterface) {
                return $value;
            }
            if (is_string($value)) {
                return new DateTimeImmutable($value);
            }
            return $value;
        }

        // Enums
        if (is_a($typeName, BackedEnum::class, true)) {
            if ($value instanceof BackedEnum) {
                return $value;
            }
            /** @var class-string<BackedEnum> $enum */
            $enum = $typeName;
            try {
                return $enum::from($value);
            } catch (\Throwable) {
                return $value;
            }
        }

        // Nested DTO hydration via static fromArray
        if (is_object($value) && is_a($value, $typeName)) {
            return $value;
        }

        if (is_array($value) && method_exists($typeName, 'fromArray')) {
            /** @phpstan-ignore-next-line */
            return $typeName::fromArray($value);
        }

        return $value;
    }

    private static function toSnake(string $v): string
    {
        $v = preg_replace('/(?<!^)[A-Z]/', '_$0', $v) ?? $v;
        return strtolower($v);
    }

    private static function toCamel(string $v): string
    {
        if (!str_contains($v, '_')) {
            return $v;
        }
        $v = str_replace('_', ' ', $v);
        $v = ucwords($v);
        $v = str_replace(' ', '', $v);
        return lcfirst($v);
    }
}
```

---
#### 10


` File: src/Support/Hydration/HydratesFromArray.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support\Hydration;

/**
 * Trait for DTOs that want a standard ::fromArray(array $data) constructor.
 *
 * This delegates to DtoHydrator which:
 * - matches constructor param names
 * - tolerates snake_case / camelCase keys
 * - hydrates nested DTOs that also support ::fromArray()
 */
trait HydratesFromArray
{
    /**
     * @param array<string,mixed> $data
     */
    public static function fromArray(array $data): static
    {
        /** @var static $dto */
        $dto = DtoHydrator::hydrate(static::class, $data);
        return $dto;
    }
}
```

---
#### 11


` File: src/Support/Result.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support;

use JsonSerializable;
use RuntimeException;
use Throwable;
use Dgp\Sdk\Support\Serialization\Arrayable;

/**
 * @template T
 */
final readonly class Result implements Arrayable, JsonSerializable
{
    /**
     * @param T|null $value
     */
    private function __construct(
        private bool      $ok,
        private mixed     $value,
        private ?DgpError $error,
    ) {}

    /**
     * @template TOut
     * @param TOut|null $value
     * @return Result<TOut>
     */
    public static function ok(mixed $value = null): self
    {
        return new self(true, $value, null);
    }

    /**
     * @template TOut
     * @return Result<TOut>
     */
    public static function fail(DgpError $error): self
    {
        return new self(false, null, $error);
    }

    /**
     * @template TOut
     * @return Result<TOut>
     */
    public static function fromThrowable(Throwable $e, ?DgpErrorCode $fallback = null): self
    {
        return self::fail(DgpError::fromThrowable($e, $fallback));
    }

    public function isOk(): bool
    {
        return $this->ok;
    }

    public function isFailure(): bool
    {
        return !$this->ok;
    }

    /**
     * @return T|null
     */
    public function value(): mixed
    {
        return $this->value;
    }

    public function error(): ?DgpError
    {
        return $this->error;
    }

    /**
     * @param callable(T):mixed $fn
     * @return Result<mixed>
     */
    public function map(callable $fn): self
    {
        if (!$this->ok) {
            return self::fail($this->error ?? DgpError::unknown());
        }

        try {
            return self::ok($fn($this->value));
        } catch (Throwable $e) {
            return self::fromThrowable($e, DgpErrorCode::UNKNOWN);
        }
    }

    /**
     * @throws RuntimeException
     * @return T
     */
    public function unwrap(): mixed
    {
        if ($this->ok) {
            return $this->value;
        }

        $err = $this->error;
        throw new RuntimeException($err ? ($err->code->value . ': ' . $err->message) : 'Result failure');
    }

    /** @return array<string, mixed> */
    public function toArray(): array
    {
        return array_filter([
            'ok' => $this->ok,
            'value' => $this->ok ? $this->value : null,
            'error' => $this->ok ? null : ($this->error?->toArray()),
        ], static fn ($v) => $v !== null);
    }

    /** @return array<string, mixed> */
    public function jsonSerialize(): array
    {
        return $this->toArray();
    }
}
```

---
#### 12


` File: src/Support/Serialization/Arrayable.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support\Serialization;

interface Arrayable
{
    /** @return array<string, mixed> */
    public function toArray(): array;
}
```

---
#### 13


` File: src/Support/Serialization/Normalizes.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support\Serialization;

use BackedEnum;
use DateTimeInterface;
use JsonSerializable;
use UnitEnum;

/**
 * Helper trait for building stable, explicit serialization arrays.
 *
 * Usage:
 *   public function jsonSerialize(): array
 *   {
 *       return $this->normalize([
 *           'id' => $this->id,
 *           'pricing_role' => $this->pricingRole,
 *           'quantityDefault' => $this->quantityDefault,
 *           'schema' => $this->schema, // Arrayable/JsonSerializable supported
 *       ]);
 *   }
 *
 * NOTE:
 * - This does NOT auto-convert key casing. You must explicitly output the keys your frontend expects.
 * - It only normalizes VALUES (nested DTOs, enums, dates, arrays) and removes nulls.
 */
trait Normalizes
{
    /**
     * Normalize an associative array:
     * - recursively normalizes values
     * - removes null values (but keeps false/0/''/[])
     *
     * @param array<string|int, mixed> $data
     * @return array<string|int, mixed>
     */
    protected function normalize(array $data): array
    {
        $out = [];

        foreach ($data as $k => $v) {
            $out[$k] = $this->normalizeValue($v);
        }

        return $this->withoutNulls($out);
    }

    /**
     * Remove ONLY null values (preserve false/0/''/[]).
     *
     * @param array<string|int, mixed> $data
     * @return array<string|int, mixed>
     */
    protected function withoutNulls(array $data): array
    {
        return array_filter($data, static fn($v) => $v !== null);
    }

    /**
     * Normalize a single value for safe JSON output.
     */
    protected function normalizeValue(mixed $value): mixed
    {
        if ($value === null) {
            return null;
        }

        // Arrays: normalize recursively
        if (is_array($value)) {
            return $this->normalizeArray($value);
        }

        // Prefer Arrayable over JsonSerializable
        if ($value instanceof Arrayable) {
            return $this->normalizeArray($value->toArray());
        }

        if ($value instanceof JsonSerializable) {
            $serialized = $value->jsonSerialize();
            return is_array($serialized) ? $this->normalizeArray($serialized) : $serialized;
        }

        // Dates: ISO-8601
        if ($value instanceof DateTimeInterface) {
            return $value->format(DATE_ATOM);
        }

        // Enums: backing value if available, else name
        if ($value instanceof BackedEnum) {
            return $value->value;
        }
        if ($value instanceof UnitEnum) {
            return $value->name;
        }

        // Scalars & objects with __toString
        if (is_scalar($value)) {
            return $value;
        }

        if (is_object($value) && method_exists($value, '__toString')) {
            return (string)$value;
        }

        // Fallback: keep as-is (host/driver may choose how to handle)
        return $value;
    }

    /**
     * Normalize arrays recursively (both list and associative).
     *
     * @param array<string|int, mixed> $arr
     * @return array<string|int, mixed>
     */
    protected function normalizeArray(array $arr): array
    {

        $out = array_map(function ($v) {
            return $this->normalizeValue($v);
        }, $arr);

        // Only remove nulls at the current level; nested calls already handled.
        return $this->withoutNulls($out);
    }
}
```

---
#### 14


` File: src/Support/Testing/FakeClock.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support\Testing;

use DateInterval;
use DateTimeImmutable;

final class FakeClock
{
    private DateTimeImmutable $now;

    public function __construct(?DateTimeImmutable $now = null)
    {
        $this->now = $now ?? new DateTimeImmutable('now');
    }

    public function now(): DateTimeImmutable
    {
        return $this->now;
    }

    public function setNow(DateTimeImmutable $now): void
    {
        $this->now = $now;
    }

    public function travel(DateInterval $interval): void
    {
        $this->now = $this->now->add($interval);
    }

    public function travelSeconds(int $seconds): void
    {
        $this->now = $this->now->modify(($seconds >= 0 ? '+' : '') . $seconds . ' seconds');
    }

    public function travelMinutes(int $minutes): void
    {
        $this->now = $this->now->modify(($minutes >= 0 ? '+' : '') . $minutes . ' minutes');
    }
}
```

---
#### 15


` File: src/Support/Testing/FakeTransport.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support\Testing;

use Closure;
use RuntimeException;
use Dgp\Sdk\Support\Result;
use Dgp\Sdk\Payloads\Requests\Infra\HttpRequestDto;
use Dgp\Sdk\Payloads\Responses\Infra\HttpResponseDto;
use Throwable;

/**
 * Simple queue-based transport fake.
 *
 * You can push:
 * - HttpResponseDto (auto wrapped into Result::ok)
 * - Result<HttpResponseDto>
 * - callable(HttpRequestDto): (HttpResponseDto|Result<HttpResponseDto>)
 * - Throwable (will be thrown)
 */
final class FakeTransport
{
    /** @var list<mixed> */
    private array $queue = [];

    /** @var list<HttpRequestDto> */
    private array $requests = [];

    public function push(HttpResponseDto|Result|Closure|Throwable $next): void
    {
        $this->queue[] = $next;
    }

    /**
     * @return list<HttpRequestDto>
     */
    public function requests(): array
    {
        return $this->requests;
    }

    public function lastRequest(): ?HttpRequestDto
    {
        return $this->requests ? $this->requests[array_key_last($this->requests)] : null;
    }

    public function reset(): void
    {
        $this->queue = [];
        $this->requests = [];
    }

    /**
     * Typical signature used by TransportContract implementations.
     *
     * @return Result<HttpResponseDto>
     * @throws Throwable
     * @throws Throwable
     */
    public function send(HttpRequestDto $request): Result
    {
        $this->requests[] = $request;

        if (!$this->queue) {
            throw new RuntimeException('FakeTransport queue is empty. Push a response before calling send().');
        }

        $next = array_shift($this->queue);

        if ($next instanceof Throwable) {
            throw $next;
        }

        if ($next instanceof Closure) {
            $next = $next($request);
        }

        if ($next instanceof Result) {
            return $next;
        }

        if ($next instanceof HttpResponseDto) {
            // Convention: Result::ok($value) exists in the SDK foundation.
            return Result::ok($next);
        }

        throw new RuntimeException('FakeTransport received an unsupported queued item.');
    }
}
```

---
#### 16


` File: src/Support/Validation/PayloadValidator.php`  [↑ Back to top](#index)

```php
<?php
declare(strict_types=1);

namespace Dgp\Sdk\Support\Validation;

use Dgp\Sdk\Support\Exceptions\ValidationException;

final class PayloadValidator
{
    /**
     * Pre-flight validation hook.
     * Keep it strict: throw ValidationException for invariant issues.
     */
    public function assertValid(mixed $dto): void
    {
        // TODO: implement per-DTO rules or attribute-based constraints.
        // This is intentionally a stub in Step 1.
        if ($dto === null) {
            throw new ValidationException('DTO must not be null');
        }
    }
}
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.11 | 2026-01-25T02:30:48.802Z -->