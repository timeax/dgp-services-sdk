// src/util/fs-utils.ts
function toPosixPath(p) {
  return p.replace(/\\/g, "/");
}

// src/ast/parser.ts
function parseStructureAst(text, opts = {}) {
  const indentStep = opts.indentStep ?? 2;
  const mode = opts.mode ?? "loose";
  const diagnostics = [];
  const lines = [];
  const rawLines = text.split(/\r?\n/);
  for (let i = 0; i < rawLines.length; i++) {
    const raw = rawLines[i];
    const lineNo = i + 1;
    const m = raw.match(/^(\s*)(.*)$/);
    const indentRaw = m ? m[1] : "";
    const content = m ? m[2] : "";
    const { indentSpaces, hasTabs } = measureIndent(indentRaw, indentStep);
    if (hasTabs) {
      diagnostics.push({
        line: lineNo,
        message: "Tabs detected in indentation. Consider using spaces only for consistent levels.",
        severity: mode === "strict" ? "warning" : "info",
        code: "indent-tabs"
      });
    }
    const trimmed = content.trim();
    let kind;
    if (!trimmed) {
      kind = "blank";
    } else if (trimmed.startsWith("#") || trimmed.startsWith("//")) {
      kind = "comment";
    } else {
      kind = "entry";
    }
    lines.push({
      index: i,
      lineNo,
      raw,
      kind,
      indentSpaces,
      content
    });
  }
  const rootNodes = [];
  const stack = [];
  const depthCtx = {
    lastIndentSpaces: null,
    lastDepth: null,
    lastWasFile: false
  };
  for (const line of lines) {
    if (line.kind !== "entry") continue;
    const { entry, depth, diags } = parseEntryLine(
      line,
      indentStep,
      mode,
      depthCtx
    );
    diagnostics.push(...diags);
    if (!entry) {
      continue;
    }
    attachNode(entry, depth, line, rootNodes, stack, diagnostics, mode);
    depthCtx.lastWasFile = !entry.isDir;
  }
  return {
    rootNodes,
    lines,
    diagnostics,
    options: {
      indentStep,
      mode
    }
  };
}
function measureIndent(rawIndent, indentStep) {
  let spaces = 0;
  let hasTabs = false;
  for (const ch of rawIndent) {
    if (ch === " ") {
      spaces += 1;
    } else if (ch === "	") {
      hasTabs = true;
      spaces += indentStep;
    }
  }
  return { indentSpaces: spaces, hasTabs };
}
function computeDepth(line, indentStep, mode, ctx, diagnostics) {
  let spaces = line.indentSpaces;
  if (spaces < 0) spaces = 0;
  let depth;
  if (ctx.lastIndentSpaces == null || ctx.lastDepth == null) {
    depth = 0;
  } else {
    const prevSpaces = ctx.lastIndentSpaces;
    const prevDepth = ctx.lastDepth;
    if (spaces > prevSpaces) {
      const diff = spaces - prevSpaces;
      if (ctx.lastWasFile) {
        diagnostics.push({
          line: line.lineNo,
          message: "Entry appears indented under a file; treating it as a sibling of the file instead of a child.",
          severity: mode === "strict" ? "error" : "warning",
          code: "child-of-file-loose"
        });
        depth = prevDepth;
      } else {
        if (diff > indentStep) {
          diagnostics.push({
            line: line.lineNo,
            message: `Indentation jumps from ${prevSpaces} to ${spaces} spaces; treating as one level deeper.`,
            severity: mode === "strict" ? "error" : "warning",
            code: "indent-skip-level"
          });
        }
        depth = prevDepth + 1;
      }
    } else if (spaces === prevSpaces) {
      depth = prevDepth;
    } else {
      const diff = prevSpaces - spaces;
      const steps = Math.round(diff / indentStep);
      if (diff % indentStep !== 0) {
        diagnostics.push({
          line: line.lineNo,
          message: `Indentation decreases from ${prevSpaces} to ${spaces} spaces, which is not a multiple of indent step (${indentStep}).`,
          severity: mode === "strict" ? "error" : "warning",
          code: "indent-misaligned"
        });
      }
      depth = Math.max(prevDepth - steps, 0);
    }
  }
  ctx.lastIndentSpaces = spaces;
  ctx.lastDepth = depth;
  return depth;
}
function parseEntryLine(line, indentStep, mode, ctx) {
  const diags = [];
  const depth = computeDepth(line, indentStep, mode, ctx, diags);
  const { contentWithoutComment } = extractInlineCommentParts(line.content);
  const trimmed = contentWithoutComment.trim();
  if (!trimmed) {
    return { entry: null, depth, diags };
  }
  const parts = trimmed.split(/\s+/);
  const pathToken = parts[0];
  const annotationTokens = parts.slice(1);
  if (pathToken.includes(":")) {
    diags.push({
      line: line.lineNo,
      message: 'Path token contains ":" which is reserved for annotations. This is likely a mistake.',
      severity: mode === "strict" ? "error" : "warning",
      code: "path-colon"
    });
  }
  const isDir = pathToken.endsWith("/");
  const segmentName = pathToken;
  let stub;
  const include = [];
  const exclude = [];
  for (const token of annotationTokens) {
    if (token.startsWith("@stub:")) {
      stub = token.slice("@stub:".length);
    } else if (token.startsWith("@include:")) {
      const val = token.slice("@include:".length);
      if (val) {
        include.push(
          ...val.split(",").map((s) => s.trim()).filter(Boolean)
        );
      }
    } else if (token.startsWith("@exclude:")) {
      const val = token.slice("@exclude:".length);
      if (val) {
        exclude.push(
          ...val.split(",").map((s) => s.trim()).filter(Boolean)
        );
      }
    } else if (token.startsWith("@")) {
      diags.push({
        line: line.lineNo,
        message: `Unknown annotation token "${token}".`,
        severity: "info",
        code: "unknown-annotation"
      });
    }
  }
  const entry = {
    segmentName,
    isDir,
    stub,
    include: include.length ? include : void 0,
    exclude: exclude.length ? exclude : void 0
  };
  return { entry, depth, diags };
}
function mapThrough(content) {
  let cutIndex = -1;
  const len = content.length;
  for (let i = 0; i < len; i++) {
    const ch = content[i];
    const prev = i > 0 ? content[i - 1] : "";
    if (ch === "#") {
      if (i === 0) {
        continue;
      }
      if (prev === " " || prev === "	") {
        cutIndex = i;
        break;
      }
    }
    if (ch === "/" && i + 1 < len && content[i + 1] === "/" && (prev === " " || prev === "	")) {
      cutIndex = i;
      break;
    }
  }
  return cutIndex;
}
function extractInlineCommentParts(content) {
  const cutIndex = mapThrough(content);
  if (cutIndex === -1) {
    return {
      contentWithoutComment: content,
      inlineComment: null
    };
  }
  return {
    contentWithoutComment: content.slice(0, cutIndex),
    inlineComment: content.slice(cutIndex)
  };
}
function attachNode(entry, depth, line, rootNodes, stack, diagnostics, mode) {
  const lineNo = line.lineNo;
  while (stack.length > depth) {
    stack.pop();
  }
  let parent = null;
  if (depth > 0) {
    const candidate = stack[depth - 1];
    if (!candidate) {
      diagnostics.push({
        line: lineNo,
        message: `Entry has indent depth ${depth} but no parent at depth ${depth - 1}. Treating as root.`,
        severity: mode === "strict" ? "error" : "warning",
        code: "missing-parent"
      });
    } else if (candidate.type === "file") {
      if (mode === "strict") {
        diagnostics.push({
          line: lineNo,
          message: `Cannot attach child under file "${candidate.path}".`,
          severity: "error",
          code: "child-of-file"
        });
      } else {
        diagnostics.push({
          line: lineNo,
          message: `Entry appears under file "${candidate.path}". Attaching as sibling at depth ${candidate.depth}.`,
          severity: "warning",
          code: "child-of-file-loose"
        });
        while (stack.length > candidate.depth) {
          stack.pop();
        }
      }
    } else {
      parent = candidate;
    }
  }
  const parentPath = parent ? parent.path.replace(/\/$/, "") : "";
  const normalizedSegment = toPosixPath(entry.segmentName.replace(/\/+$/, ""));
  const fullPath = parentPath ? `${parentPath}/${normalizedSegment}${entry.isDir ? "/" : ""}` : `${normalizedSegment}${entry.isDir ? "/" : ""}`;
  const baseNode = {
    type: entry.isDir ? "dir" : "file",
    name: entry.segmentName,
    depth,
    line: lineNo,
    path: fullPath,
    parent,
    ...entry.stub ? { stub: entry.stub } : {},
    ...entry.include ? { include: entry.include } : {},
    ...entry.exclude ? { exclude: entry.exclude } : {}
  };
  if (entry.isDir) {
    const dirNode = {
      ...baseNode,
      type: "dir",
      children: []
    };
    if (parent) {
      parent.children.push(dirNode);
    } else {
      rootNodes.push(dirNode);
    }
    while (stack.length > depth) {
      stack.pop();
    }
    stack[depth] = dirNode;
  } else {
    const fileNode = {
      ...baseNode,
      type: "file"
    };
    if (parent) {
      parent.children.push(fileNode);
    } else {
      rootNodes.push(fileNode);
    }
  }
}

// src/ast/format.ts
function formatStructureText(text, options = {}) {
  const indentStep = options.indentStep ?? 2;
  const mode = options.mode ?? "loose";
  const normalizeNewlines = options.normalizeNewlines === void 0 ? true : options.normalizeNewlines;
  const trimTrailingWhitespace = options.trimTrailingWhitespace === void 0 ? true : options.trimTrailingWhitespace;
  const normalizeAnnotations = options.normalizeAnnotations === void 0 ? true : options.normalizeAnnotations;
  const ast = parseStructureAst(text, {
    indentStep,
    mode
  });
  const rawLines = text.split(/\r?\n/);
  const lineCount = rawLines.length;
  if (ast.lines.length !== lineCount) {
    return {
      text: basicNormalize(text, { normalizeNewlines, trimTrailingWhitespace }),
      ast
    };
  }
  const entryLineIndexes = [];
  const inlineComments = [];
  for (let i = 0; i < lineCount; i++) {
    const lineMeta = ast.lines[i];
    if (lineMeta.kind === "entry") {
      entryLineIndexes.push(i);
      const { inlineComment } = extractInlineCommentParts(lineMeta.content);
      inlineComments.push(inlineComment);
    }
  }
  const flattened = [];
  flattenAstNodes(ast.rootNodes, 0, flattened);
  if (flattened.length !== entryLineIndexes.length) {
    return {
      text: basicNormalize(text, { normalizeNewlines, trimTrailingWhitespace }),
      ast
    };
  }
  const canonicalEntryLines = flattened.map(
    ({ node, level }) => formatAstNodeLine(node, level, indentStep, normalizeAnnotations)
  );
  const resultLines = [];
  let entryIdx = 0;
  for (let i = 0; i < lineCount; i++) {
    const lineMeta = ast.lines[i];
    const originalLine = rawLines[i];
    if (lineMeta.kind === "entry") {
      const base = canonicalEntryLines[entryIdx].replace(/[ \t]+$/g, "");
      const inline = inlineComments[entryIdx];
      entryIdx++;
      if (inline) {
        resultLines.push(base + " " + inline);
      } else {
        resultLines.push(base);
      }
    } else {
      let out = originalLine;
      if (trimTrailingWhitespace) {
        out = out.replace(/[ \t]+$/g, "");
      }
      resultLines.push(out);
    }
  }
  const eol = normalizeNewlines ? detectPreferredEol(text) : getRawEol(text);
  return {
    text: resultLines.join(eol),
    ast
  };
}
function basicNormalize(text, opts) {
  const lines = text.split(/\r?\n/);
  const normalizedLines = opts.trimTrailingWhitespace ? lines.map((line) => line.replace(/[ \t]+$/g, "")) : lines;
  const eol = opts.normalizeNewlines ? detectPreferredEol(text) : getRawEol(text);
  return normalizedLines.join(eol);
}
function detectPreferredEol(text) {
  const crlfCount = (text.match(/\r\n/g) || []).length;
  const lfCount = (text.match(/(?<!\r)\n/g) || []).length;
  if (crlfCount === 0 && lfCount === 0) {
    return "\n";
  }
  if (crlfCount > lfCount) {
    return "\r\n";
  }
  return "\n";
}
function getRawEol(text) {
  return text.includes("\r\n") ? "\r\n" : "\n";
}
function flattenAstNodes(nodes, level, out) {
  for (const node of nodes) {
    out.push({ node, level });
    if (node.type === "dir" && node.children && node.children.length) {
      flattenAstNodes(node.children, level + 1, out);
    }
  }
}
function formatAstNodeLine(node, level, indentStep, normalizeAnnotations) {
  const indent = " ".repeat(indentStep * level);
  const baseName = node.name;
  if (!normalizeAnnotations) {
    return indent + baseName;
  }
  const tokens = [];
  if (node.stub) {
    tokens.push(`@stub:${node.stub}`);
  }
  if (node.include && node.include.length > 0) {
    tokens.push(`@include:${node.include.join(",")}`);
  }
  if (node.exclude && node.exclude.length > 0) {
    tokens.push(`@exclude:${node.exclude.join(",")}`);
  }
  const annotations = tokens.length ? " " + tokens.join(" ") : "";
  return indent + baseName + annotations;
}

export { extractInlineCommentParts, formatStructureText, mapThrough, parseStructureAst };
//# sourceMappingURL=ast.mjs.map
//# sourceMappingURL=ast.mjs.map