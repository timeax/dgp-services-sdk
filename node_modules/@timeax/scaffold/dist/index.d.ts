import { S as ScaffoldConfig, a as ScanStructureOptions, b as ScanFromConfigOptions, c as StructureEntry } from './config-DBARTF0g.js';
export { B as BaseEntryOptions, D as DirEntry, F as FileEntry, l as FormatConfig, k as FormatMode, H as HookContext, e as HookFilter, h as RegularHookConfig, f as RegularHookFn, R as RegularHookKind, m as StructureGroupConfig, j as StubConfig, i as StubHookConfig, g as StubHookFn, d as StubHookKind } from './config-DBARTF0g.js';

declare const SCAFFOLD_ROOT_DIR = ".scaffold";

type LogLevel = 'silent' | 'error' | 'warn' | 'info' | 'debug';
interface LoggerOptions {
    level?: LogLevel;
    /**
     * Optional prefix string (e.g. "[scaffold]" or "[group:app]").
     */
    prefix?: string;
}
/**
 * Minimal logger for @timeax/scaffold with colored output.
 */
declare class Logger {
    private level;
    private prefix;
    constructor(options?: LoggerOptions);
    setLevel(level: LogLevel): void;
    getLevel(): LogLevel;
    /**
     * Create a child logger with an additional prefix.
     */
    child(prefix: string): Logger;
    private formatMessage;
    private shouldLog;
    error(msg: unknown, ...rest: unknown[]): void;
    warn(msg: unknown, ...rest: unknown[]): void;
    info(msg: unknown, ...rest: unknown[]): void;
    debug(msg: unknown, ...rest: unknown[]): void;
}

interface InteractiveDeleteParams {
    absolutePath: string;
    relativePath: string;
    size: number;
    createdByStub?: string;
    groupName?: string;
}

interface RunOptions {
    /**
     * Optional interactive delete callback; if omitted, deletions
     * above the size threshold will be skipped (kept + removed from cache).
     */
    interactiveDelete?: (params: InteractiveDeleteParams) => Promise<'delete' | 'keep'>;
    /**
     * Optional logger override.
     */
    logger?: Logger;
    /**
     * Optional overrides (e.g. allow CLI to point at a different scaffold dir).
     */
    scaffoldDir?: string;
    configPath?: string;
    /**
     * If true, force formatting even if config.format?.enabled === false.
     * This is what `--format` will use.
     */
    format?: boolean;
}
/**
 * Run scaffold once for the current working directory.
 */
declare function runOnce(cwd: string, options?: RunOptions): Promise<void>;

interface LoadScaffoldConfigOptions {
    /**
     * Optional explicit scaffold directory path (absolute or relative to cwd).
     * If provided, this overrides config.root for locating the scaffold folder.
     */
    scaffoldDir?: string;
    /**
     * Optional explicit config file path (absolute or relative to cwd).
     * If not provided, we look for config.* inside the scaffoldDir.
     */
    configPath?: string;
}
interface LoadScaffoldConfigResult {
    /**
     * Parsed scaffold configuration.
     */
    config: ScaffoldConfig;
    /**
     * Absolute path to the scaffold directory (where config & *.txt live).
     */
    scaffoldDir: string;
    /**
     * Effective project root BASE where structures are applied.
     * This is derived from config.root + config.base.
     */
    projectRoot: string;
}
/**
 * Load scaffold configuration based on CWD + optional overrides + config.root/base.
 *
 * Resolution rules:
 * - configRoot:
 *   - Start from cwd.
 *   - Apply config.root (if defined) as a path relative to cwd.
 * - scaffoldDir:
 *   - If options.scaffoldDir is provided → use it as-is (resolved from cwd).
 *   - Else → <configRoot>/scaffold.
 * - projectRoot (base):
 *   - If config.base is defined → resolve relative to configRoot.
 *   - Else → configRoot.
 */
declare function loadScaffoldConfig(cwd: string, options?: LoadScaffoldConfigOptions): Promise<LoadScaffoldConfigResult>;

/**
 * Generate a structure.txt-style tree from an existing directory.
 *
 * Indenting:
 * - 2 spaces per level.
 * - Directories suffixed with "/".
 * - No stub/include/exclude annotations are guessed (plain tree).
 */
declare function scanDirectoryToStructureText(rootDir: string, options?: ScanStructureOptions): string;
/**
 * Result of scanning based on the scaffold config.
 *
 * You can use `structureFilePath` + `text` to write out group structure files.
 */
interface ScanFromConfigResult {
    groupName: string;
    groupRoot: string;
    structureFileName: string;
    structureFilePath: string;
    text: string;
}
/**
 * Scan the project using the scaffold config and its groups.
 *
 * - If `config.groups` exists and is non-empty:
 *   - scans each group's `root` (relative to projectRoot)
 *   - produces text suitable for that group's structure file
 * - Otherwise:
 *   - scans the single `projectRoot` and produces text for a single structure file.
 *
 * NOTE: This function does NOT write files; it just returns what should be written.
 * The CLI (or caller) decides whether/where to save.
 */
declare function scanProjectFromConfig(cwd: string, options?: ScanFromConfigOptions): Promise<ScanFromConfigResult[]>;
/**
 * Convenience helper: write scan results to their structure files.
 *
 * This will ensure the scaffold directory exists and overwrite existing
 * structure files.
 */
declare function writeScannedStructuresFromConfig(cwd: string, options?: ScanFromConfigOptions): Promise<void>;
interface EnsureStructuresResult {
    created: string[];
    existing: string[];
}
/**
 * Ensure all structure files declared in the config exist.
 *
 * - Grouped mode: one file per group (group.structureFile || `${group.name}.txt`)
 * - Single-root mode: config.structureFile || "structure.txt"
 *
 * Existing files are left untouched. Only missing files are created with
 * a small header comment.
 */
declare function ensureStructureFilesFromConfig(cwd: string, options?: {
    scaffoldDirOverride?: string;
}): Promise<EnsureStructuresResult>;

/**
 * Convert a structure.txt content into a nested StructureEntry[].
 *
 * Rules:
 * - Indentation is **indentStep** spaces per level (default: 2).
 * - Indent must be a multiple of indentStep.
 * - You cannot "skip" levels (no jumping from level 0 to 2 directly).
 * - **Only directories can have children**:
 *   - If you indent under a file, an error is thrown.
 * - Folders must end with "/" in the txt; paths are normalized to POSIX.
 */
declare function parseStructureText(fileName: string, text: string, indentStep?: number): StructureEntry[];

export { type EnsureStructuresResult, type LoadScaffoldConfigOptions, type LoadScaffoldConfigResult, type RunOptions, SCAFFOLD_ROOT_DIR, ScaffoldConfig, ScanFromConfigOptions, type ScanFromConfigResult, ScanStructureOptions, StructureEntry, ensureStructureFilesFromConfig, loadScaffoldConfig, parseStructureText, runOnce, scanDirectoryToStructureText, scanProjectFromConfig, writeScannedStructuresFromConfig };
