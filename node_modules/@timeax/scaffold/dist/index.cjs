'use strict';

var path5 = require('path');
var fs2 = require('fs');
var os = require('os');
var crypto = require('crypto');
var url = require('url');
var esbuild = require('esbuild');
var minimatch = require('minimatch');
var pluralize = require('pluralize');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var path5__default = /*#__PURE__*/_interopDefault(path5);
var fs2__default = /*#__PURE__*/_interopDefault(fs2);
var os__default = /*#__PURE__*/_interopDefault(os);
var crypto__default = /*#__PURE__*/_interopDefault(crypto);
var pluralize__default = /*#__PURE__*/_interopDefault(pluralize);

// src/schema/index.ts
var SCAFFOLD_ROOT_DIR = ".scaffold";

// src/util/logger.ts
var supportsColor = typeof process !== "undefined" && process.stdout && process.stdout.isTTY && process.env.NO_COLOR !== "1";
function wrap(code) {
  const open = `\x1B[${code}m`;
  const close = `\x1B[0m`;
  return (text) => supportsColor ? `${open}${text}${close}` : text;
}
var color = {
  red: wrap(31),
  yellow: wrap(33),
  green: wrap(32),
  cyan: wrap(36),
  magenta: wrap(35),
  dim: wrap(2),
  bold: wrap(1),
  gray: wrap(90)
};
function colorForLevel(level) {
  switch (level) {
    case "error":
      return color.red;
    case "warn":
      return color.yellow;
    case "info":
      return color.cyan;
    case "debug":
      return color.gray;
    default:
      return (s) => s;
  }
}
var Logger = class _Logger {
  level;
  prefix;
  constructor(options = {}) {
    this.level = options.level ?? "info";
    this.prefix = options.prefix;
  }
  setLevel(level) {
    this.level = level;
  }
  getLevel() {
    return this.level;
  }
  /**
   * Create a child logger with an additional prefix.
   */
  child(prefix) {
    const combined = this.prefix ? `${this.prefix}${prefix}` : prefix;
    return new _Logger({ level: this.level, prefix: combined });
  }
  formatMessage(msg, lvl) {
    const text = typeof msg === "string" ? msg : msg instanceof Error ? msg.message : String(msg);
    const levelColor = colorForLevel(lvl);
    const prefixColored = this.prefix ? color.magenta(this.prefix) : void 0;
    const textColored = lvl === "debug" ? color.dim(text) : levelColor(text);
    if (prefixColored) {
      return `${prefixColored} ${textColored}`;
    }
    return textColored;
  }
  shouldLog(targetLevel) {
    const order = ["silent", "error", "warn", "info", "debug"];
    const currentIdx = order.indexOf(this.level);
    const targetIdx = order.indexOf(targetLevel);
    if (currentIdx === -1 || targetIdx === -1) return true;
    if (this.level === "silent") return false;
    return targetIdx <= currentIdx || targetLevel === "error";
  }
  error(msg, ...rest) {
    if (!this.shouldLog("error")) return;
    console.error(this.formatMessage(msg, "error"), ...rest);
  }
  warn(msg, ...rest) {
    if (!this.shouldLog("warn")) return;
    console.warn(this.formatMessage(msg, "warn"), ...rest);
  }
  info(msg, ...rest) {
    if (!this.shouldLog("info")) return;
    console.log(this.formatMessage(msg, "info"), ...rest);
  }
  debug(msg, ...rest) {
    if (!this.shouldLog("debug")) return;
    console.debug(this.formatMessage(msg, "debug"), ...rest);
  }
};
var defaultLogger = new Logger({
  level: process.env.SCAFFOLD_LOG_LEVEL ?? "info",
  prefix: "[scaffold]"
});
function toPosixPath(p) {
  return p.replace(/\\/g, "/");
}
function ensureDirSync(dirPath) {
  if (!fs2__default.default.existsSync(dirPath)) {
    fs2__default.default.mkdirSync(dirPath, { recursive: true });
  }
  return dirPath;
}
function statSafeSync(targetPath) {
  try {
    return fs2__default.default.statSync(targetPath);
  } catch {
    return null;
  }
}
function toProjectRelativePath(projectRoot, absolutePath) {
  const absRoot = path5__default.default.resolve(projectRoot);
  const absTarget = path5__default.default.resolve(absolutePath);
  const rootWithSep = absRoot.endsWith(path5__default.default.sep) ? absRoot : absRoot + path5__default.default.sep;
  if (!absTarget.startsWith(rootWithSep) && absTarget !== absRoot) {
    throw new Error(
      `Path "${absTarget}" is not inside project root "${absRoot}".`
    );
  }
  const rel = path5__default.default.relative(absRoot, absTarget);
  return toPosixPath(rel);
}

// src/core/config-loader.ts
var logger = defaultLogger.child("[config]");
async function loadScaffoldConfig(cwd, options = {}) {
  const absCwd = path5__default.default.resolve(cwd);
  const initialScaffoldDir = options.scaffoldDir ? path5__default.default.resolve(absCwd, options.scaffoldDir) : path5__default.default.join(absCwd, SCAFFOLD_ROOT_DIR);
  const configPath = options.configPath ?? resolveConfigPath(initialScaffoldDir);
  const config = await importConfig(configPath);
  let configRoot = absCwd;
  if (config.root) {
    configRoot = path5__default.default.resolve(absCwd, config.root);
  }
  const scaffoldDir = options.scaffoldDir ? path5__default.default.resolve(absCwd, options.scaffoldDir) : path5__default.default.join(configRoot, SCAFFOLD_ROOT_DIR);
  const baseRoot = config.base ? path5__default.default.resolve(configRoot, config.base) : configRoot;
  logger.debug(
    `Loaded config: configRoot=${configRoot}, baseRoot=${baseRoot}, scaffoldDir=${scaffoldDir}`
  );
  return {
    config,
    scaffoldDir,
    projectRoot: baseRoot
  };
}
function resolveConfigPath(scaffoldDir) {
  const candidates = [
    "config.ts",
    "config.mts",
    "config.mjs",
    "config.js",
    "config.cjs"
  ];
  for (const file of candidates) {
    const full = path5__default.default.join(scaffoldDir, file);
    if (fs2__default.default.existsSync(full)) {
      return full;
    }
  }
  throw new Error(
    `Could not find scaffold config in ${scaffoldDir}. Looked for: ${candidates.join(
      ", "
    )}`
  );
}
async function importConfig(configPath) {
  const ext = path5__default.default.extname(configPath).toLowerCase();
  if (ext === ".ts" || ext === ".tsx") {
    return importTsConfig(configPath);
  }
  const url$1 = url.pathToFileURL(configPath).href;
  const mod = await import(url$1);
  return mod.default ?? mod;
}
async function importTsConfig(configPath) {
  const source = fs2__default.default.readFileSync(configPath, "utf8");
  const stat = fs2__default.default.statSync(configPath);
  const hash = crypto__default.default.createHash("sha1").update(configPath).update(String(stat.mtimeMs)).digest("hex");
  const tmpDir = path5__default.default.join(os__default.default.tmpdir(), "timeax-scaffold-config");
  ensureDirSync(tmpDir);
  const tmpFile = path5__default.default.join(tmpDir, `${hash}.mjs`);
  if (!fs2__default.default.existsSync(tmpFile)) {
    const result = await esbuild.transform(source, {
      loader: "ts",
      format: "esm",
      sourcemap: "inline",
      target: "ESNext",
      tsconfigRaw: {
        compilerOptions: {}
      }
    });
    fs2__default.default.writeFileSync(tmpFile, result.code, "utf8");
  }
  const url$1 = url.pathToFileURL(tmpFile).href;
  const mod = await import(url$1);
  return mod.default ?? mod;
}

// src/ast/parser.ts
function parseStructureAst(text, opts = {}) {
  const indentStep = opts.indentStep ?? 2;
  const mode = opts.mode ?? "loose";
  const diagnostics = [];
  const lines = [];
  const rawLines = text.split(/\r?\n/);
  for (let i = 0; i < rawLines.length; i++) {
    const raw = rawLines[i];
    const lineNo = i + 1;
    const m = raw.match(/^(\s*)(.*)$/);
    const indentRaw = m ? m[1] : "";
    const content = m ? m[2] : "";
    const { indentSpaces, hasTabs } = measureIndent(indentRaw, indentStep);
    if (hasTabs) {
      diagnostics.push({
        line: lineNo,
        message: "Tabs detected in indentation. Consider using spaces only for consistent levels.",
        severity: mode === "strict" ? "warning" : "info",
        code: "indent-tabs"
      });
    }
    const trimmed = content.trim();
    let kind;
    if (!trimmed) {
      kind = "blank";
    } else if (trimmed.startsWith("#") || trimmed.startsWith("//")) {
      kind = "comment";
    } else {
      kind = "entry";
    }
    lines.push({
      index: i,
      lineNo,
      raw,
      kind,
      indentSpaces,
      content
    });
  }
  const rootNodes = [];
  const stack = [];
  const depthCtx = {
    lastIndentSpaces: null,
    lastDepth: null,
    lastWasFile: false
  };
  for (const line of lines) {
    if (line.kind !== "entry") continue;
    const { entry, depth, diags } = parseEntryLine(
      line,
      indentStep,
      mode,
      depthCtx
    );
    diagnostics.push(...diags);
    if (!entry) {
      continue;
    }
    attachNode(entry, depth, line, rootNodes, stack, diagnostics, mode);
    depthCtx.lastWasFile = !entry.isDir;
  }
  return {
    rootNodes,
    lines,
    diagnostics,
    options: {
      indentStep,
      mode
    }
  };
}
function measureIndent(rawIndent, indentStep) {
  let spaces = 0;
  let hasTabs = false;
  for (const ch of rawIndent) {
    if (ch === " ") {
      spaces += 1;
    } else if (ch === "	") {
      hasTabs = true;
      spaces += indentStep;
    }
  }
  return { indentSpaces: spaces, hasTabs };
}
function computeDepth(line, indentStep, mode, ctx, diagnostics) {
  let spaces = line.indentSpaces;
  if (spaces < 0) spaces = 0;
  let depth;
  if (ctx.lastIndentSpaces == null || ctx.lastDepth == null) {
    depth = 0;
  } else {
    const prevSpaces = ctx.lastIndentSpaces;
    const prevDepth = ctx.lastDepth;
    if (spaces > prevSpaces) {
      const diff = spaces - prevSpaces;
      if (ctx.lastWasFile) {
        diagnostics.push({
          line: line.lineNo,
          message: "Entry appears indented under a file; treating it as a sibling of the file instead of a child.",
          severity: mode === "strict" ? "error" : "warning",
          code: "child-of-file-loose"
        });
        depth = prevDepth;
      } else {
        if (diff > indentStep) {
          diagnostics.push({
            line: line.lineNo,
            message: `Indentation jumps from ${prevSpaces} to ${spaces} spaces; treating as one level deeper.`,
            severity: mode === "strict" ? "error" : "warning",
            code: "indent-skip-level"
          });
        }
        depth = prevDepth + 1;
      }
    } else if (spaces === prevSpaces) {
      depth = prevDepth;
    } else {
      const diff = prevSpaces - spaces;
      const steps = Math.round(diff / indentStep);
      if (diff % indentStep !== 0) {
        diagnostics.push({
          line: line.lineNo,
          message: `Indentation decreases from ${prevSpaces} to ${spaces} spaces, which is not a multiple of indent step (${indentStep}).`,
          severity: mode === "strict" ? "error" : "warning",
          code: "indent-misaligned"
        });
      }
      depth = Math.max(prevDepth - steps, 0);
    }
  }
  ctx.lastIndentSpaces = spaces;
  ctx.lastDepth = depth;
  return depth;
}
function parseEntryLine(line, indentStep, mode, ctx) {
  const diags = [];
  const depth = computeDepth(line, indentStep, mode, ctx, diags);
  const { contentWithoutComment } = extractInlineCommentParts(line.content);
  const trimmed = contentWithoutComment.trim();
  if (!trimmed) {
    return { entry: null, depth, diags };
  }
  const parts = trimmed.split(/\s+/);
  const pathToken = parts[0];
  const annotationTokens = parts.slice(1);
  if (pathToken.includes(":")) {
    diags.push({
      line: line.lineNo,
      message: 'Path token contains ":" which is reserved for annotations. This is likely a mistake.',
      severity: mode === "strict" ? "error" : "warning",
      code: "path-colon"
    });
  }
  const isDir = pathToken.endsWith("/");
  const segmentName = pathToken;
  let stub;
  const include = [];
  const exclude = [];
  for (const token of annotationTokens) {
    if (token.startsWith("@stub:")) {
      stub = token.slice("@stub:".length);
    } else if (token.startsWith("@include:")) {
      const val = token.slice("@include:".length);
      if (val) {
        include.push(
          ...val.split(",").map((s) => s.trim()).filter(Boolean)
        );
      }
    } else if (token.startsWith("@exclude:")) {
      const val = token.slice("@exclude:".length);
      if (val) {
        exclude.push(
          ...val.split(",").map((s) => s.trim()).filter(Boolean)
        );
      }
    } else if (token.startsWith("@")) {
      diags.push({
        line: line.lineNo,
        message: `Unknown annotation token "${token}".`,
        severity: "info",
        code: "unknown-annotation"
      });
    }
  }
  const entry = {
    segmentName,
    isDir,
    stub,
    include: include.length ? include : void 0,
    exclude: exclude.length ? exclude : void 0
  };
  return { entry, depth, diags };
}
function mapThrough(content) {
  let cutIndex = -1;
  const len = content.length;
  for (let i = 0; i < len; i++) {
    const ch = content[i];
    const prev = i > 0 ? content[i - 1] : "";
    if (ch === "#") {
      if (i === 0) {
        continue;
      }
      if (prev === " " || prev === "	") {
        cutIndex = i;
        break;
      }
    }
    if (ch === "/" && i + 1 < len && content[i + 1] === "/" && (prev === " " || prev === "	")) {
      cutIndex = i;
      break;
    }
  }
  return cutIndex;
}
function extractInlineCommentParts(content) {
  const cutIndex = mapThrough(content);
  if (cutIndex === -1) {
    return {
      contentWithoutComment: content,
      inlineComment: null
    };
  }
  return {
    contentWithoutComment: content.slice(0, cutIndex),
    inlineComment: content.slice(cutIndex)
  };
}
function attachNode(entry, depth, line, rootNodes, stack, diagnostics, mode) {
  const lineNo = line.lineNo;
  while (stack.length > depth) {
    stack.pop();
  }
  let parent = null;
  if (depth > 0) {
    const candidate = stack[depth - 1];
    if (!candidate) {
      diagnostics.push({
        line: lineNo,
        message: `Entry has indent depth ${depth} but no parent at depth ${depth - 1}. Treating as root.`,
        severity: mode === "strict" ? "error" : "warning",
        code: "missing-parent"
      });
    } else if (candidate.type === "file") {
      if (mode === "strict") {
        diagnostics.push({
          line: lineNo,
          message: `Cannot attach child under file "${candidate.path}".`,
          severity: "error",
          code: "child-of-file"
        });
      } else {
        diagnostics.push({
          line: lineNo,
          message: `Entry appears under file "${candidate.path}". Attaching as sibling at depth ${candidate.depth}.`,
          severity: "warning",
          code: "child-of-file-loose"
        });
        while (stack.length > candidate.depth) {
          stack.pop();
        }
      }
    } else {
      parent = candidate;
    }
  }
  const parentPath = parent ? parent.path.replace(/\/$/, "") : "";
  const normalizedSegment = toPosixPath(entry.segmentName.replace(/\/+$/, ""));
  const fullPath = parentPath ? `${parentPath}/${normalizedSegment}${entry.isDir ? "/" : ""}` : `${normalizedSegment}${entry.isDir ? "/" : ""}`;
  const baseNode = {
    type: entry.isDir ? "dir" : "file",
    name: entry.segmentName,
    depth,
    line: lineNo,
    path: fullPath,
    parent,
    ...entry.stub ? { stub: entry.stub } : {},
    ...entry.include ? { include: entry.include } : {},
    ...entry.exclude ? { exclude: entry.exclude } : {}
  };
  if (entry.isDir) {
    const dirNode = {
      ...baseNode,
      type: "dir",
      children: []
    };
    if (parent) {
      parent.children.push(dirNode);
    } else {
      rootNodes.push(dirNode);
    }
    while (stack.length > depth) {
      stack.pop();
    }
    stack[depth] = dirNode;
  } else {
    const fileNode = {
      ...baseNode,
      type: "file"
    };
    if (parent) {
      parent.children.push(fileNode);
    } else {
      rootNodes.push(fileNode);
    }
  }
}

// src/ast/format.ts
function formatStructureText(text, options = {}) {
  const indentStep = options.indentStep ?? 2;
  const mode = options.mode ?? "loose";
  const normalizeNewlines = options.normalizeNewlines === void 0 ? true : options.normalizeNewlines;
  const trimTrailingWhitespace = options.trimTrailingWhitespace === void 0 ? true : options.trimTrailingWhitespace;
  const normalizeAnnotations = options.normalizeAnnotations === void 0 ? true : options.normalizeAnnotations;
  const ast = parseStructureAst(text, {
    indentStep,
    mode
  });
  const rawLines = text.split(/\r?\n/);
  const lineCount = rawLines.length;
  if (ast.lines.length !== lineCount) {
    return {
      text: basicNormalize(text, { normalizeNewlines, trimTrailingWhitespace }),
      ast
    };
  }
  const entryLineIndexes = [];
  const inlineComments = [];
  for (let i = 0; i < lineCount; i++) {
    const lineMeta = ast.lines[i];
    if (lineMeta.kind === "entry") {
      entryLineIndexes.push(i);
      const { inlineComment } = extractInlineCommentParts(lineMeta.content);
      inlineComments.push(inlineComment);
    }
  }
  const flattened = [];
  flattenAstNodes(ast.rootNodes, 0, flattened);
  if (flattened.length !== entryLineIndexes.length) {
    return {
      text: basicNormalize(text, { normalizeNewlines, trimTrailingWhitespace }),
      ast
    };
  }
  const canonicalEntryLines = flattened.map(
    ({ node, level }) => formatAstNodeLine(node, level, indentStep, normalizeAnnotations)
  );
  const resultLines = [];
  let entryIdx = 0;
  for (let i = 0; i < lineCount; i++) {
    const lineMeta = ast.lines[i];
    const originalLine = rawLines[i];
    if (lineMeta.kind === "entry") {
      const base = canonicalEntryLines[entryIdx].replace(/[ \t]+$/g, "");
      const inline = inlineComments[entryIdx];
      entryIdx++;
      if (inline) {
        resultLines.push(base + " " + inline);
      } else {
        resultLines.push(base);
      }
    } else {
      let out = originalLine;
      if (trimTrailingWhitespace) {
        out = out.replace(/[ \t]+$/g, "");
      }
      resultLines.push(out);
    }
  }
  const eol = normalizeNewlines ? detectPreferredEol(text) : getRawEol(text);
  return {
    text: resultLines.join(eol),
    ast
  };
}
function basicNormalize(text, opts) {
  const lines = text.split(/\r?\n/);
  const normalizedLines = opts.trimTrailingWhitespace ? lines.map((line) => line.replace(/[ \t]+$/g, "")) : lines;
  const eol = opts.normalizeNewlines ? detectPreferredEol(text) : getRawEol(text);
  return normalizedLines.join(eol);
}
function detectPreferredEol(text) {
  const crlfCount = (text.match(/\r\n/g) || []).length;
  const lfCount = (text.match(/(?<!\r)\n/g) || []).length;
  if (crlfCount === 0 && lfCount === 0) {
    return "\n";
  }
  if (crlfCount > lfCount) {
    return "\r\n";
  }
  return "\n";
}
function getRawEol(text) {
  return text.includes("\r\n") ? "\r\n" : "\n";
}
function flattenAstNodes(nodes, level, out) {
  for (const node of nodes) {
    out.push({ node, level });
    if (node.type === "dir" && node.children && node.children.length) {
      flattenAstNodes(node.children, level + 1, out);
    }
  }
}
function formatAstNodeLine(node, level, indentStep, normalizeAnnotations) {
  const indent = " ".repeat(indentStep * level);
  const baseName = node.name;
  if (!normalizeAnnotations) {
    return indent + baseName;
  }
  const tokens = [];
  if (node.stub) {
    tokens.push(`@stub:${node.stub}`);
  }
  if (node.include && node.include.length > 0) {
    tokens.push(`@include:${node.include.join(",")}`);
  }
  if (node.exclude && node.exclude.length > 0) {
    tokens.push(`@exclude:${node.exclude.join(",")}`);
  }
  const annotations = tokens.length ? " " + tokens.join(" ") : "";
  return indent + baseName + annotations;
}

// src/core/structure-txt.ts
function stripInlineComment(content) {
  const cutIndex = mapThrough(content);
  if (cutIndex === -1) {
    return content.trimEnd();
  }
  return content.slice(0, cutIndex).trimEnd();
}
function parseLine(line, lineNo, fileName) {
  const match = line.match(/^(\s*)(.*)$/);
  if (!match) return null;
  const indentSpaces = match[1].length;
  let rest = match[2];
  if (!rest.trim()) return null;
  const trimmedRest = rest.trimStart();
  if (trimmedRest.startsWith("#") || trimmedRest.startsWith("//")) {
    return null;
  }
  const stripped = stripInlineComment(rest);
  const trimmed = stripped.trim();
  if (!trimmed) return null;
  const parts = trimmed.split(/\s+/);
  if (!parts.length) return null;
  const pathToken = parts[0];
  if (pathToken.includes(":")) {
    throw new Error(
      `${fileName}: ":" is reserved for annotations (@stub:, @include:, etc). Invalid path "${pathToken}" on line ${lineNo}.`
    );
  }
  let stub;
  const include = [];
  const exclude = [];
  for (const token of parts.slice(1)) {
    if (token.startsWith("@stub:")) {
      stub = token.slice("@stub:".length);
    } else if (token.startsWith("@include:")) {
      const val = token.slice("@include:".length);
      if (val) {
        include.push(
          ...val.split(",").map((s) => s.trim()).filter(Boolean)
        );
      }
    } else if (token.startsWith("@exclude:")) {
      const val = token.slice("@exclude:".length);
      if (val) {
        exclude.push(
          ...val.split(",").map((s) => s.trim()).filter(Boolean)
        );
      }
    }
  }
  return {
    lineNo,
    indentSpaces,
    rawPath: pathToken,
    stub,
    include: include.length ? include : void 0,
    exclude: exclude.length ? exclude : void 0
  };
}
function parseStructureText(fileName, text, indentStep = 2) {
  const lines = text.split(/\r?\n/);
  const parsed = [];
  for (let i = 0; i < lines.length; i++) {
    const lineNo = i + 1;
    const p = parseLine(lines[i], lineNo, fileName);
    if (p) parsed.push(p);
  }
  const rootEntries = [];
  const stack = [];
  for (const p of parsed) {
    const { indentSpaces, lineNo } = p;
    if (indentSpaces % indentStep !== 0) {
      throw new Error(
        `${fileName}: Invalid indent on line ${lineNo}. Indent must be multiples of ${indentStep} spaces.`
      );
    }
    const level = indentSpaces / indentStep;
    if (level > stack.length) {
      if (level !== stack.length + 1) {
        throw new Error(
          `${fileName}: Invalid indentation on line ${lineNo}. You cannot jump more than one level at a time. Previous depth: ${stack.length}, this line depth: ${level}.`
        );
      }
    }
    if (level > 0) {
      const parent2 = stack[level - 1];
      if (!parent2) {
        throw new Error(
          `${fileName}: Indented entry without a parent on line ${lineNo}.`
        );
      }
      if (!parent2.isDir) {
        throw new Error(
          `${fileName}: Cannot indent under a file on line ${lineNo}. Files cannot have children. Parent: "${parent2.entry.path}".`
        );
      }
    }
    const isDir = p.rawPath.endsWith("/");
    const clean = p.rawPath.replace(/\/$/, "");
    const basePath = toPosixPath(clean);
    while (stack.length > level) {
      stack.pop();
    }
    const parent = stack[stack.length - 1]?.entry;
    const parentPath = parent ? parent.path.replace(/\/$/, "") : "";
    const fullPath = parentPath ? `${parentPath}/${basePath}${isDir ? "/" : ""}` : `${basePath}${isDir ? "/" : ""}`;
    if (isDir) {
      const dirEntry = {
        type: "dir",
        path: fullPath,
        children: [],
        ...p.stub ? { stub: p.stub } : {},
        ...p.include ? { include: p.include } : {},
        ...p.exclude ? { exclude: p.exclude } : {}
      };
      if (parent && parent.type === "dir") {
        parent.children = parent.children ?? [];
        parent.children.push(dirEntry);
      } else if (!parent) {
        rootEntries.push(dirEntry);
      }
      stack.push({ level, entry: dirEntry, isDir: true });
    } else {
      const fileEntry = {
        type: "file",
        path: fullPath,
        ...p.stub ? { stub: p.stub } : {},
        ...p.include ? { include: p.include } : {},
        ...p.exclude ? { exclude: p.exclude } : {}
      };
      if (parent && parent.type === "dir") {
        parent.children = parent.children ?? [];
        parent.children.push(fileEntry);
      } else if (!parent) {
        rootEntries.push(fileEntry);
      }
      stack.push({ level, entry: fileEntry, isDir: false });
    }
  }
  return rootEntries;
}

// src/core/resolve-structure.ts
var logger2 = defaultLogger.child("[structure]");
function resolveGroupStructure(scaffoldDir, group, config) {
  if (group.structure && group.structure.length) {
    logger2.debug(`Using inline structure for group "${group.name}"`);
    return group.structure;
  }
  const fileName = group.structureFile ?? `${group.name}.txt`;
  const filePath = path5__default.default.join(scaffoldDir, fileName);
  if (!fs2__default.default.existsSync(filePath)) {
    throw new Error(
      `@timeax/scaffold: Group "${group.name}" has no structure. Expected file "${fileName}" in "${scaffoldDir}".`
    );
  }
  logger2.debug(`Reading structure for group "${group.name}" from ${filePath}`);
  const raw = fs2__default.default.readFileSync(filePath, "utf8");
  return parseStructureText(fileName, raw, config.indentStep);
}
function resolveSingleStructure(scaffoldDir, config) {
  if (config.structure && config.structure.length) {
    logger2.debug("Using inline single structure (no groups)");
    return config.structure;
  }
  const fileName = config.structureFile ?? "structure.txt";
  const filePath = path5__default.default.join(scaffoldDir, fileName);
  if (!fs2__default.default.existsSync(filePath)) {
    throw new Error(
      `@timeax/scaffold: No structure defined. Expected "${fileName}" in "${scaffoldDir}".`
    );
  }
  logger2.debug(`Reading single structure from ${filePath}`);
  const raw = fs2__default.default.readFileSync(filePath, "utf8");
  return parseStructureText(fileName, raw, config.indentStep);
}
var logger3 = defaultLogger.child("[cache]");
var DEFAULT_CACHE = {
  version: 1,
  entries: {}
};
var CacheManager = class {
  constructor(projectRoot, cacheFileRelPath) {
    this.projectRoot = projectRoot;
    this.cacheFileRelPath = cacheFileRelPath;
  }
  cache = DEFAULT_CACHE;
  get cachePathAbs() {
    return path5__default.default.resolve(this.projectRoot, this.cacheFileRelPath);
  }
  load() {
    const cachePath = this.cachePathAbs;
    if (!fs2__default.default.existsSync(cachePath)) {
      this.cache = { ...DEFAULT_CACHE, entries: {} };
      return;
    }
    try {
      const raw = fs2__default.default.readFileSync(cachePath, "utf8");
      const parsed = JSON.parse(raw);
      if (parsed.version === 1 && parsed.entries) {
        this.cache = parsed;
      } else {
        logger3.warn("Cache file version mismatch or invalid, resetting cache.");
        this.cache = { ...DEFAULT_CACHE, entries: {} };
      }
    } catch (err) {
      logger3.warn("Failed to read cache file, resetting cache.", err);
      this.cache = { ...DEFAULT_CACHE, entries: {} };
    }
  }
  save() {
    const cachePath = this.cachePathAbs;
    const dir = path5__default.default.dirname(cachePath);
    ensureDirSync(dir);
    fs2__default.default.writeFileSync(cachePath, JSON.stringify(this.cache, null, 2), "utf8");
  }
  get(relPath) {
    const key = toPosixPath(relPath);
    return this.cache.entries[key];
  }
  set(entry) {
    const key = toPosixPath(entry.path);
    this.cache.entries[key] = {
      ...entry,
      path: key
    };
  }
  delete(relPath) {
    const key = toPosixPath(relPath);
    delete this.cache.entries[key];
  }
  allPaths() {
    return Object.keys(this.cache.entries);
  }
  allEntries() {
    return Object.values(this.cache.entries);
  }
};
function matchesFilter(pathRel, cfg) {
  const { include, exclude, files } = cfg;
  const patterns = [];
  if (include?.length) patterns.push(...include);
  if (files?.length) patterns.push(...files);
  if (patterns.length) {
    const ok = patterns.some((p) => minimatch.minimatch(pathRel, p));
    if (!ok) return false;
  }
  if (exclude?.length) {
    const blocked = exclude.some((p) => minimatch.minimatch(pathRel, p));
    if (blocked) return false;
  }
  return true;
}
var HookRunner = class {
  constructor(config) {
    this.config = config;
  }
  async runRegular(kind, ctx) {
    const configs = this.config.hooks?.[kind] ?? [];
    for (const cfg of configs) {
      if (!matchesFilter(ctx.targetPath, cfg)) continue;
      await cfg.fn(ctx);
    }
  }
  getStubConfig(stubName) {
    if (!stubName) return void 0;
    return this.config.stubs?.[stubName];
  }
  async runStub(kind, ctx) {
    const stub = this.getStubConfig(ctx.stubName);
    if (!stub?.hooks) return;
    const configs = kind === "preStub" ? stub.hooks.preStub ?? [] : stub.hooks.postStub ?? [];
    for (const cfg of configs) {
      if (!matchesFilter(ctx.targetPath, cfg)) continue;
      await cfg.fn(ctx);
    }
  }
  async renderStubContent(ctx) {
    const stub = this.getStubConfig(ctx.stubName);
    if (!stub?.getContent) return void 0;
    return stub.getContent(ctx);
  }
};
async function applyStructure(opts) {
  const {
    config,
    projectRoot,
    baseDir,
    structure,
    cache,
    hooks,
    groupName,
    groupRoot,
    sizePromptThreshold,
    interactiveDelete
  } = opts;
  const logger5 = opts.logger ?? defaultLogger.child(groupName ? `[apply:${groupName}]` : "[apply]");
  const projectRootAbs = path5__default.default.resolve(projectRoot);
  const baseDirAbs = path5__default.default.resolve(baseDir);
  baseDirAbs.endsWith(path5__default.default.sep) ? baseDirAbs : baseDirAbs + path5__default.default.sep;
  const desiredPaths = /* @__PURE__ */ new Set();
  const threshold = sizePromptThreshold ?? config.sizePromptThreshold ?? 128 * 1024;
  async function walk(entry, inheritedStub) {
    const effectiveStub = entry.stub ?? inheritedStub;
    if (entry.type === "dir") {
      await handleDir(entry, effectiveStub);
    } else {
      await handleFile(entry, effectiveStub);
    }
  }
  async function handleDir(entry, inheritedStub) {
    const relFromBase = entry.path.replace(/^[./]+/, "");
    const absDir = path5__default.default.resolve(baseDirAbs, relFromBase);
    const relFromRoot = toPosixPath(
      toProjectRelativePath(projectRootAbs, absDir)
    );
    desiredPaths.add(relFromRoot);
    ensureDirSync(absDir);
    const nextStub = entry.stub ?? inheritedStub;
    if (entry.children) {
      for (const child of entry.children) {
        await walk(child, nextStub);
      }
    }
  }
  async function handleFile(entry, inheritedStub) {
    const relFromBase = entry.path.replace(/^[./]+/, "");
    const absFile = path5__default.default.resolve(baseDirAbs, relFromBase);
    const relFromRoot = toPosixPath(
      toProjectRelativePath(projectRootAbs, absFile)
    );
    desiredPaths.add(relFromRoot);
    const stubName = entry.stub ?? inheritedStub;
    const extension = path5__default.default.extname(relFromRoot);
    const fileName = path5__default.default.basename(relFromRoot, extension);
    const ctx = {
      projectRoot: projectRootAbs,
      targetPath: relFromRoot,
      absolutePath: absFile,
      isDirectory: false,
      fileName,
      dirName: path5__default.default.dirname(relFromRoot),
      extension,
      pluralFileName: pluralize__default.default.plural(fileName),
      stubName
    };
    if (fs2__default.default.existsSync(absFile)) {
      return;
    }
    await hooks.runRegular("preCreateFile", ctx);
    const dir = path5__default.default.dirname(absFile);
    ensureDirSync(dir);
    if (stubName) {
      await hooks.runStub("preStub", ctx);
    }
    let content = "";
    const stubContent = await hooks.renderStubContent(ctx);
    if (typeof stubContent === "string") {
      content = stubContent;
    }
    fs2__default.default.writeFileSync(absFile, content, "utf8");
    const stats = fs2__default.default.statSync(absFile);
    cache.set({
      path: relFromRoot,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      sizeAtCreate: stats.size,
      createdByStub: stubName,
      groupName,
      groupRoot
    });
    logger5.info(`created ${relFromRoot}`);
    if (stubName) {
      await hooks.runStub("postStub", ctx);
    }
    await hooks.runRegular("postCreateFile", ctx);
  }
  for (const entry of structure) {
    await walk(entry);
  }
  for (const cachedPath of cache.allPaths()) {
    const entry = cache.get(cachedPath);
    if (groupName) {
      if (!entry || entry.groupName !== groupName) {
        continue;
      }
    } else {
      if (entry && entry.groupName) {
        continue;
      }
    }
    if (desiredPaths.has(cachedPath)) {
      continue;
    }
    const abs = path5__default.default.resolve(projectRoot, cachedPath);
    const stats = statSafeSync(abs);
    if (!stats) {
      cache.delete(cachedPath);
      continue;
    }
    if (!stats.isFile()) {
      cache.delete(cachedPath);
      continue;
    }
    const extension = path5__default.default.extname(abs);
    const fileName = path5__default.default.basename(abs, extension);
    const ctx = {
      projectRoot,
      targetPath: cachedPath,
      absolutePath: abs,
      isDirectory: false,
      fileName,
      dirName: path5__default.default.dirname(cachedPath),
      extension,
      pluralFileName: pluralize__default.default.plural(fileName),
      stubName: entry?.createdByStub
    };
    await hooks.runRegular("preDeleteFile", ctx);
    let shouldDelete = true;
    if (stats.size > threshold && interactiveDelete) {
      const res = await interactiveDelete({
        absolutePath: abs,
        relativePath: cachedPath,
        size: stats.size,
        createdByStub: entry?.createdByStub,
        groupName: entry?.groupName
      });
      if (res === "keep") {
        shouldDelete = false;
        cache.delete(cachedPath);
        logger5.info(`keeping ${cachedPath} (removed from cache)`);
      }
    }
    if (shouldDelete) {
      try {
        fs2__default.default.unlinkSync(abs);
        logger5.info(`deleted ${cachedPath}`);
      } catch (err) {
        logger5.warn(`failed to delete ${cachedPath}`, err);
      }
      cache.delete(cachedPath);
      await hooks.runRegular("postDeleteFile", ctx);
    }
  }
}
function getStructureFilesFromConfig(projectRoot, scaffoldDir, config) {
  const baseDir = path5__default.default.resolve(projectRoot, scaffoldDir || SCAFFOLD_ROOT_DIR);
  const files = [];
  if (config.groups && config.groups.length > 0) {
    for (const group of config.groups) {
      const structureFile = group.structureFile && group.structureFile.trim().length ? group.structureFile : `${group.name}.txt`;
      files.push(path5__default.default.join(baseDir, structureFile));
    }
  } else {
    const structureFile = config.structureFile || "structure.txt";
    files.push(path5__default.default.join(baseDir, structureFile));
  }
  return files;
}
async function formatStructureFilesFromConfig(projectRoot, scaffoldDir, config, opts = {}) {
  const formatCfg = config.format;
  const enabled = !!(formatCfg?.enabled || opts.force);
  if (!enabled) return;
  const files = getStructureFilesFromConfig(projectRoot, scaffoldDir, config);
  const indentStep = formatCfg?.indentStep ?? config.indentStep ?? 2;
  const mode = formatCfg?.mode ?? "loose";
  !!formatCfg?.sortEntries;
  for (const filePath of files) {
    let text;
    try {
      text = fs2__default.default.readFileSync(filePath, "utf8");
    } catch {
      continue;
    }
    const { text: formatted } = formatStructureText(text, {
      indentStep,
      mode});
    if (formatted !== text) {
      fs2__default.default.writeFileSync(filePath, formatted, "utf8");
    }
  }
}

// src/core/runner.ts
async function runOnce(cwd, options = {}) {
  const logger5 = options.logger ?? defaultLogger.child("[runner]");
  const { config, scaffoldDir, projectRoot } = await loadScaffoldConfig(cwd, {
    scaffoldDir: options.scaffoldDir,
    configPath: options.configPath
  });
  await formatStructureFilesFromConfig(projectRoot, scaffoldDir, config, { force: options.format });
  const cachePath = config.cacheFile ?? ".scaffold-cache.json";
  const cache = new CacheManager(projectRoot, cachePath);
  cache.load();
  const hooks = new HookRunner(config);
  if (config.groups && config.groups.length > 0) {
    for (const group of config.groups) {
      const groupRootAbs = path5__default.default.resolve(projectRoot, group.root);
      const structure = resolveGroupStructure(scaffoldDir, group, config);
      const groupLogger = logger5.child(`[group:${group.name}]`);
      await applyStructure({
        config,
        projectRoot,
        baseDir: groupRootAbs,
        structure,
        cache,
        hooks,
        groupName: group.name,
        groupRoot: group.root,
        interactiveDelete: options.interactiveDelete,
        logger: groupLogger
      });
    }
  } else {
    const structure = resolveSingleStructure(scaffoldDir, config);
    const baseLogger = logger5.child("[group:default]");
    await applyStructure({
      config,
      projectRoot,
      baseDir: projectRoot,
      structure,
      cache,
      hooks,
      groupName: "default",
      groupRoot: ".",
      interactiveDelete: options.interactiveDelete,
      logger: baseLogger
    });
  }
  cache.save();
}
var logger4 = defaultLogger.child("[scan]");
var DEFAULT_IGNORE = [
  "node_modules/**",
  ".git/**",
  "dist/**",
  "build/**",
  ".turbo/**",
  ".next/**",
  "coverage/**"
];
function scanDirectoryToStructureText(rootDir, options = {}) {
  const absRoot = path5__default.default.resolve(rootDir);
  const lines = [];
  const ignorePatterns = options.ignore ?? DEFAULT_IGNORE;
  const maxDepth = options.maxDepth ?? Infinity;
  function isIgnored(absPath) {
    const rel = toPosixPath(path5__default.default.relative(absRoot, absPath));
    if (!rel || rel === ".") return false;
    return ignorePatterns.some(
      (pattern) => minimatch.minimatch(rel, pattern, { dot: true })
    );
  }
  function walk(currentAbs, depth) {
    if (depth > maxDepth) return;
    let dirents;
    try {
      dirents = fs2__default.default.readdirSync(currentAbs, { withFileTypes: true });
    } catch {
      return;
    }
    dirents.sort((a, b) => {
      if (a.isDirectory() && !b.isDirectory()) return -1;
      if (!a.isDirectory() && b.isDirectory()) return 1;
      return a.name.localeCompare(b.name);
    });
    for (const dirent of dirents) {
      const name = dirent.name;
      const absPath = path5__default.default.join(currentAbs, name);
      if (isIgnored(absPath)) continue;
      const indent = "  ".repeat(depth);
      if (dirent.isDirectory()) {
        lines.push(`${indent}${name}/`);
        walk(absPath, depth + 1);
      } else if (dirent.isFile()) {
        lines.push(`${indent}${name}`);
      }
    }
  }
  walk(absRoot, 0);
  return lines.join("\n");
}
async function scanProjectFromConfig(cwd, options = {}) {
  const { config, scaffoldDir, projectRoot } = await loadScaffoldConfig(cwd, {
    scaffoldDir: options.scaffoldDir
  });
  const ignorePatterns = options.ignore ?? DEFAULT_IGNORE;
  const maxDepth = options.maxDepth ?? Infinity;
  const onlyGroups = options.groups;
  const results = [];
  function scanGroup(cfg, group) {
    const rootAbs = path5__default.default.resolve(projectRoot, group.root);
    const text = scanDirectoryToStructureText(rootAbs, {
      ignore: ignorePatterns,
      maxDepth
    });
    const structureFileName = group.structureFile ?? `${group.name}.txt`;
    const structureFilePath = path5__default.default.join(scaffoldDir, structureFileName);
    return {
      groupName: group.name,
      groupRoot: group.root,
      structureFileName,
      structureFilePath,
      text
    };
  }
  if (config.groups && config.groups.length > 0) {
    logger4.debug(
      `Scanning project from config with ${config.groups.length} group(s).`
    );
    for (const group of config.groups) {
      if (onlyGroups && !onlyGroups.includes(group.name)) {
        continue;
      }
      const result = scanGroup(config, group);
      results.push(result);
    }
  } else {
    logger4.debug("Scanning project in single-root mode (no groups).");
    const text = scanDirectoryToStructureText(projectRoot, {
      ignore: ignorePatterns,
      maxDepth
    });
    const structureFileName = config.structureFile ?? "structure.txt";
    const structureFilePath = path5__default.default.join(scaffoldDir, structureFileName);
    results.push({
      groupName: "default",
      groupRoot: ".",
      structureFileName,
      structureFilePath,
      text
    });
  }
  return results;
}
async function writeScannedStructuresFromConfig(cwd, options = {}) {
  const { scaffoldDir } = await loadScaffoldConfig(cwd, {
    scaffoldDir: options.scaffoldDir
  });
  ensureDirSync(scaffoldDir);
  const results = await scanProjectFromConfig(cwd, options);
  for (const result of results) {
    fs2__default.default.writeFileSync(result.structureFilePath, result.text, "utf8");
    logger4.info(
      `Wrote structure for group "${result.groupName}" to ${result.structureFilePath}`
    );
  }
}
async function ensureStructureFilesFromConfig(cwd, options = {}) {
  const { config, scaffoldDir } = await loadScaffoldConfig(cwd, {
    scaffoldDir: options.scaffoldDirOverride
  });
  ensureDirSync(scaffoldDir);
  const created = [];
  const existing = [];
  const seen = /* @__PURE__ */ new Set();
  const ensureFile = (fileName) => {
    if (!fileName) return;
    const filePath = path5__default.default.join(scaffoldDir, fileName);
    const key = path5__default.default.resolve(filePath);
    if (seen.has(key)) return;
    seen.add(key);
    if (fs2__default.default.existsSync(filePath)) {
      existing.push(filePath);
      return;
    }
    const header = `# ${fileName}
# Structure file for @timeax/scaffold
# Define your desired folders/files here.
`;
    fs2__default.default.writeFileSync(filePath, header, "utf8");
    created.push(filePath);
  };
  if (config.groups && config.groups.length > 0) {
    for (const group of config.groups) {
      const fileName = group.structureFile ?? `${group.name}.txt`;
      ensureFile(fileName);
    }
  } else {
    const fileName = config.structureFile ?? "structure.txt";
    ensureFile(fileName);
  }
  logger4.debug(
    `ensureStructureFilesFromConfig: created=${created.length}, existing=${existing.length}`
  );
  return { created, existing };
}

exports.SCAFFOLD_ROOT_DIR = SCAFFOLD_ROOT_DIR;
exports.ensureStructureFilesFromConfig = ensureStructureFilesFromConfig;
exports.loadScaffoldConfig = loadScaffoldConfig;
exports.parseStructureText = parseStructureText;
exports.runOnce = runOnce;
exports.scanDirectoryToStructureText = scanDirectoryToStructureText;
exports.scanProjectFromConfig = scanProjectFromConfig;
exports.writeScannedStructuresFromConfig = writeScannedStructuresFromConfig;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map